#!/bin/sh

. $( dirname "$0" )/common.sh

repipe
in_dir="$1"
load_source

eval $( jq -r '{
  "version_commit": .version.commit,
  "version_status": .version.status
} | to_entries[] | .key + "=" + @sh "\(.value)"' < /tmp/stdin )

#
# check retry counter
#

REMAINING_TRIES="${retry_count:-5}"

while true; do

#
# lookup
#

curlgh "$source_endpoint/repos/$source_repository/commits/$version_commit/status" \
  | jq -c \
    --arg status "$version_status" \
    '{
      "sha": .sha,
      "status": ( .statuses | map(select( $status == ( .id | tostring ) )) | .[0] )
    }' \
    > /tmp/status


#
# validate
#

jq -e '.status' < /tmp/status > /dev/null
check_status="$?"

if [ "$check_status" -eq 0 ]; then
  break
elif [ "$check_status" -gt 0 ] && [ "$REMAINING_TRIES" -le 1 ]; then
  fatal "Status not found on $( jq -r '.sha' < /tmp/status )"
fi

#
# decrease retry counter and loop
#

REMAINING_TRIES=$(($REMAINING_TRIES - 1))

sleep "${retry_timeout:-3}"

done

#
# concourse
#

jq -j -r '.sha' < /tmp/status > "$in_dir/commit"
jq -j -r '.status.description // ""' < /tmp/status > "$in_dir/description"
jq -j -r '.status.state' < /tmp/status > "$in_dir/state"
jq -j -r '.status.target_url // ""' < /tmp/status > "$in_dir/target_url"
jq -j -r '.status.updated_at' < /tmp/status > "$in_dir/updated_at"

jq -c \
  --arg commit "$version_commit" \
  --arg status "$version_status" \
  '{
    "version": {
      "commit": ( $commit | tostring ),
      "status": ( $status | tostring )
    },
    "metadata": [
      {
        "name": "created_at",
        "value": .status.created_at
      }
    ]
  }' \
  < /tmp/status \
  >&3
